{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/java/writing-javadoc/",
    "result": {"data":{"cur":{"id":"bd170e79-ab0d-561a-91af-a749367d6427","html":"<p>최근에 Jetty기반의 서버를 하나 개발하게 되었다. 릴리스를 할 수 있는 수준까지 개발이 되었고, 진척이 됨에 따라 중간중간에 주석으로만 남겨두거나 간단하게만 적었던 설명들을 Javadoc을 이용해서 구체화하게 되었다. Javadoc은 소스코드 주석을 이용해 API 문서를 만드는 유틸리티고, 지금까지도 Java 문서화하면 먼저 나오는 단어들 중 하나일만큼 유명하다. 유명하고 자주 봐서 그런지 그만큼 사용하기 편한 것 같아서 나도 이용하게 되었다. 이번 글에서는 내가 어떻게 Javadoc을 사용했는지 남겨본다.</p>\n<h2 id=\"1-javadoc이-필요한가\" style=\"position:relative;\"><a href=\"#1-javadoc%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%9C%EA%B0%80\" aria-label=\"1 javadoc이 필요한가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Javadoc이 필요한가?</h2>\n<p>일단 소스코드 상으로 보는 문서가 아니라 페이지 형태로 정리된 문서는 내가 원하는 클래스를 찾기 편하게 만든다고 생각한다. JDK API reference들도 보면 javaadoc으로 만들어졌는데, 패키지와 클래스가 왼쪽 메뉴에 있다. 이를 통해서 원하는 이름의 클래스를 쉽게 찾을 수 있고, 클래스를 쉽게 찾으면 원하는 인터페이스를 찾는데 더 도움이 된다고 생각한다.</p>\n<p>또한 소스코드 상에서도 Javadoc은 <code class=\"language-text\">//</code> 으로 적는 주석보다 낫다고 생각한다. <code class=\"language-text\">@link</code> 같은 태그들로 다른 인터페이스를 연결해두면 분석을 위해 소스를 보는 시간이 크게 줄어든다고 생각한다.</p>\n<h2 id=\"2-기본적인-사용법\" style=\"position:relative;\"><a href=\"#2-%EA%B8%B0%EB%B3%B8%EC%A0%81%EC%9D%B8-%EC%82%AC%EC%9A%A9%EB%B2%95\" aria-label=\"2 기본적인 사용법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 기본적인 사용법</h2>\n<p>문서화할 주석을 다는 경우에는 <code class=\"language-text\">/** */</code> 안에 내용이 들어가 있으면 된다. 특별한 내용을 다룰 때는 <code class=\"language-text\">@</code>로 시작하는 태그들을 사용한다. 주로 사용하는 태그는 <code class=\"language-text\">@link</code>, <code class=\"language-text\">@param</code>, <code class=\"language-text\">@throws</code> 정도이고, 그 외에도 사용되는 태그들에는 <code class=\"language-text\">@author</code>, <code class=\"language-text\">@deprecated</code>, <code class=\"language-text\">@since</code>, <code class=\"language-text\">{@code}</code> 정도가 있다.</p>\n<p><a href=\"https://www.oracle.com/technetwork/articles/java/index-137868.html\">Orcale에서 제공하는 Javadoc guide</a>에는 어떻게 작성하는지 대략적인 가이드가 나와 있다. 가이드와 나의 경험을 섞어서 요약하자면 아래와 같다.</p>\n<ul>\n<li>첫 줄에는 주석 시작을 나타내는 문자(<code class=\"language-text\">/**</code>)</li>\n<li>첫 문장은 현재 작성하는 메서드에 대한 요약.\n<ul>\n<li>메서드 요약 테이블과 인덱스에 위치됨</li>\n<li>메스드 요약 같은 경우에는 두 줄까지 나오더라.</li>\n</ul>\n</li>\n<li><code class=\"language-text\">{@link URL}</code> 형식으로 참조하게 할 링크를 명시하라는데, <code class=\"language-text\">${className}#${interfaceName}</code> 형식으로 작성하면 Javadoc을 생성했을 때 해당 인터페이스의 링크가 걸린다.</li>\n<li>만약 할 말이 많아서 문단이 구분되어야 한다면 구분되는 라인에 <code class=\"language-text\">&lt;p></code> 태그를 넣으면 된다. newline을 넣고 싶다면 <code class=\"language-text\">&lt;br></code> 로 넣을 수 있다.</li>\n<li>설명과 태그 사이에는 공백 라인을 하나 넣을 것</li>\n<li><code class=\"language-text\">@</code> 으로 시작하는 라인이 나오면 설명 부분은 끝나게 된다고 한다. <code class=\"language-text\">@</code> 로 시작하는 라인 이후에 다시 설명 부분이 나오거나 할 수는 없다고 한다.</li>\n<li>마지막 라인은 주석이 끝났음을 나타내는 문자(<code class=\"language-text\">*/</code>)</li>\n</ul>\n<p>그래서 예시를 들자면 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">/**\n * This controls certian functions.\n * Parameter argument should satisfy certain contains. \n * &lt;p>\n * Other paragraphs can also be made. \n *\n * @param   parameter   object giving something of something\n * @return              object of the result processed by the given parameter\n * @see     {@link SomeClass#someMethod}\n*/</span>\n\n\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">SomeClass</span> <span class=\"token function\">someMethod</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SomeOhterClass</span> parameter<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// do something...</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SomeClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">someSetter</span><span class=\"token punctuation\">(</span>something<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"3-조그마한-이슈들\" style=\"position:relative;\"><a href=\"#3-%EC%A1%B0%EA%B7%B8%EB%A7%88%ED%95%9C-%EC%9D%B4%EC%8A%88%EB%93%A4\" aria-label=\"3 조그마한 이슈들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 조그마한 이슈들</h2>\n<h3 id=\"3-1-커스텀-태그\" style=\"position:relative;\"><a href=\"#3-1-%EC%BB%A4%EC%8A%A4%ED%85%80-%ED%83%9C%EA%B7%B8\" aria-label=\"3 1 커스텀 태그 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-1. 커스텀 태그</h3>\n<p>Spark나 Javalin같은 웹 프레임워크들을 사용할 때는 엔드포인트들을 구현하게 된다. 예를 들면 (GET)<code class=\"language-text\">/api/message/send</code> 엔드포인트의 요청을 받아서 처리하는 엔드포인트를 <code class=\"language-text\">messageSend</code> 라는 변수로 구현했을 때 <code class=\"language-text\">messageSend</code> 라는 변수의 설명을 달아야 하는데, 이 변수는 엔드포인트의 구현이라는 설명을 하고 싶을 수 있다. 이럴 경우 <code class=\"language-text\">@Endpoint /api/message/send</code> 와 같은 태그를 사용하면 어떨까? 하는 생각을 할 수 있는데, <code class=\"language-text\">@Endpoint</code>는 Javadoc에서 기본적으로 제공하는 태그가 아니다.</p>\n<p>위와 같이 커스텀 태그를 사용하고 싶으면 Javadoc을 실행할 때 옵션에 커스텀태그에 대한 명시를 해주면 된다. <code class=\"language-text\">-tag custom.${tag_name}:${Xaoptcmf}:\"${tag_head}\"</code> 형식으로 사용할 수 있다. 소스코드 상에서 <code class=\"language-text\">@tag_name</code> 이라고 명시하면 <code class=\"language-text\">tag_head</code> 라는 제목의 태그로 바뀌는데, <code class=\"language-text\">Xaoptcmf</code> 의 속성을 가진다는 뜻이다. <code class=\"language-text\">Xaoptcmf</code> 중 하나의 글자가 들어가는데, 각 글자가 의미하는 바는 아래와 같다.</p>\n<ul>\n<li>X (태그 무효화)</li>\n<li>a (모든 위치)</li>\n<li>o (개요)</li>\n<li>p (패키지)</li>\n<li>t (형태 : 클래스 및 인터페이스)</li>\n<li>c (생성자)</li>\n<li>m (메서드)</li>\n<li>f (필드)</li>\n</ul>\n<h3 id=\"3-2-인코딩\" style=\"position:relative;\"><a href=\"#3-2-%EC%9D%B8%EC%BD%94%EB%94%A9\" aria-label=\"3 2 인코딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-2. 인코딩</h3>\n<p>보통 Javadoc을 만들 정도의 프로젝트는 사내 프로덕트이고, 보통의 한국 회사라면 구성원들은 대부분 한국어가 모국어이기 때문에 아무리 소스코드와 함께 작성한다지만 한국어로 Javadoc을 적는 경우가 다수이다. Javadoc의 경우 한국어로 적으면 생성이 제대로 안 될 수 있다. <code class=\"language-text\">unmappable character for encoding ASCII</code> 같은 오류와 함께 생성이 실패하게 되는데, 이럴 경우 <code class=\"language-text\">locale</code>, <code class=\"language-text\">charset</code>, <code class=\"language-text\">encoding</code>, <code class=\"language-text\">docencoding</code> 옵션으로 한국어의 경우 UTF-8을 사용하도록 하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-locale ko_KR -charset UTF-8 -encoding UTF-8 -docencoding UTF-8</code></pre></div>\n<h2 id=\"4-마무리\" style=\"position:relative;\"><a href=\"#4-%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"4 마무리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 마무리</h2>\n<p>솔직히 말해서 요즘은 내가 가지고있는 소스코드, 빌드 자동화 툴(e.g. gradle) 등을 통해 받은 라이브러리 둘 다 IDE를 통하면 Javadoc을 충분히 볼 수 있다. 코딩을 하는 과정에서 설명이 필요한 메서드 등이 있으면 단축키를 통해 바로 이동할 수 있어서 이동한 지점에 있는 Javadoc 소스를 보면 된다. 또한 하나의 인터페이스에서 제공하는 메서드들의 목록을 볼 때도 쉽게 볼 수 있다. IntelliJ 같은 경우는 인터페이스 이름을 입력하고 <code class=\"language-text\">.</code> 을 누르면 드롭다운(?) 같은 리스트로 지원하는 함수 목록이 나열될 정도로 편리한 기능을 제공하고 있어서 Javadoc의 필요성이 많이 떨어졌을 수 있다. 그러나 여전히 Javadoc은 비교적 쉽게 소스에 대한 설명을 볼 수 있는 유용한 도구이니 필요한 경우 적극적으로 사용할 수 있을 것 같다고 생각한다.</p>","excerpt":"최근에 Jetty기반의 서버를 하나 개발하게 되었다. 릴리스를 할 수 있는 수준까지 개발이 되었고, 진척이 됨에 따라 중간중간에 주석으로만 남겨두거나 간단하게만 적었던 설명들을 Javadoc을 이용해서 구체화하게 되었다. Javadoc은 소스코드 주석을 이용해 API 문서를 만드는 유틸리티고, 지금까지도 Java 문서화하면 먼저 나오는 단어들 중 하나일만큼 유명하다. 유명하고 자주 봐서 그런지 그만큼 사용하기 편한 것 같아서 나도 이용하게 되었다. 이번 글에서는 내가 어떻게 Javadoc을 사용했는지 남겨본다. 1. Javadoc이 필요한가? 일단 소스코드 상으로 보는 문서가 아니라 페이지 형태로 정리된 문서는 내가 원하는 클래스를 찾기 편하게 만든다고 생각한다. JDK API reference들도 보면 javaadoc으로 만들어졌는데, 패키지와 클래스가 왼쪽 메뉴에 있다. 이를 통해서 원하는 이름의 클래스를 쉽게 찾을 수 있고, 클래스를 쉽게 찾으면 원하는 인터페이스를 찾는데 더…","frontmatter":{"date":"December 16, 2019","title":"Javadoc 작성기","categories":"Tech","author":"fleta","emoji":"🔮"},"fields":{"slug":"/java/writing-javadoc/"}},"next":{"id":"14ce6bbb-62b5-50ff-91c7-9645021b9e0e","html":"<p>근래 어떤 서비스를 구현하는 과정에서 요청의 유효성을 판단할 용도인 키의 처리를 위해 암호화를 고민하게 되었다. 그래서 이번 글에서는 암호화 알고리즘 적용 과정에서 나왔던 질문에 대한 내 나름대로의 정리를 남겨보고자 한다.</p>\n<h2 id=\"1-암호화-암호화-알고리즘\" style=\"position:relative;\"><a href=\"#1-%EC%95%94%ED%98%B8%ED%99%94-%EC%95%94%ED%98%B8%ED%99%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"1 암호화 암호화 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 암호화? 암호화 알고리즘?</h2>\n<p>암호화를 한마디로 정의하자면 “수학적인 과정을 통해 정보를 가진 문자열을 의미 없는 문자열로 바꾸는 것” 정도라고 생각한다.</p>\n<p>암호화 알고리즘을 설계할 때 confusion과 diffusion의 성질을 이용한다. 이 성질들을 얻기 위해 substituion과 permutation이 사용되며, 이들을 적절히 조합하여 round를 만들고 구성된 round들을 반복하는 방식으로 암호화가 이루어진다.</p>\n<p>Confusion과 diffusion에 대해서 간단하게 설명하면..</p>\n<ul>\n<li>통계 및 암호화 분석 방법으로 암호를 분석하기 어렵게 방해하는 성질들\n<ul>\n<li>따라서 생성된 값의 역상관관계(decorrelation)가 중요한 해쉬 함수나 의사 난수 생성기의 설계 등에서 중요하게 생각되어야 함.</li>\n<li>복잡성은 잘 정의되고 반복된 일련의 substition과 permutation을 통해 구현됨</li>\n</ul>\n</li>\n<li>Confusion (혼돈): 암호문과 키 사이의 관계를 가능한 복잡하게 만드는 것\n<ul>\n<li>암호문의 각 binary digit(bit)이 키의 여러 부분에 의존성을 가져야 함.</li>\n</ul>\n</li>\n<li>Diffusion(확산): 암호문에 대한 평문의 통계적 구조를 소멸시키는 것.\n<ul>\n<li>평문의 1 bit를 바꾸면 통계적으로 절반의 암호문 bit가 바뀌어야 함.\n<ul>\n<li>암호문의 1 bit를 바꾸어도 통계적으로 절반의 평문 bit도 바뀌어야 함.</li>\n<li>bit는 두 가지 성질만 가질 수 있으니 bit가 임의의 한 위치에서 다른 위치로 바뀌었을 때 절반의 bit의 상태가 변경되어야 함.</li>\n</ul>\n</li>\n<li>평문을 행과 열에 분산시켜 중복성을 증가시킴.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-hash\" style=\"position:relative;\"><a href=\"#2-hash\" aria-label=\"2 hash permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Hash</h2>\n<blockquote>\n<p>해시 함수(hash function)는 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수이다. 해시 함수에 의해 얻어지는 값은 해시 값, 해시 코드, 해시 체크섬</p>\n</blockquote>\n<p>또는 간단하게 해시라고 한다.</p>\n<p><a href=\"https://ko.wikipedia.org/wiki/%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98\">https://ko.wikipedia.org/wiki/%ED%95%B4%EC%8B%9C_%ED%95%A8%EC%88%98</a> 에 나온 해시 함수에 대한 정의이다.</p>\n<p>정의에도 나와 있듯이 hash는 길이가 다양한 데이터를 고정된 길이의 데이터로 변환하는데, 그렇다보니 digest의 개수보다 key값이 더 많을 수 밖에 없다. 서로 다른 key를 가지고 hashing해도 같은 값이 나오는 경우가 있을 수 있다. 이를 Hash collision이라고 부른다. 나는 Hash collision이 없는 hash function은 없는 것으로 알고 있다. 디디클레의 원리(비둘기집의 원리)가 이를 증명하는 것으로 보인다.</p>\n<p>또한 hash function을 통해 생성된 digest로는 원본을 구할수가 없어야 한다. 그래서 hash function 자체는 암호화를 할 때 이용할 수 있지만 암호화/복호화를 같이 할 수 있게 만들어진 함수가 아니다.</p>\n<p>Hash algorithm의 종류는 대표적으로 SHA(Secure Hash Algorithm), MD5 (Message Digest) 정도가 있다. 커밋에 붙어있는 해쉬라던가 소프트웨어가 릴리스 될 때 나오는 checksum 등에서 그 예를 찾아볼 수 있다.</p>\n<h2 id=\"3-hash의-단점-및-보완\" style=\"position:relative;\"><a href=\"#3-hash%EC%9D%98-%EB%8B%A8%EC%A0%90-%EB%B0%8F-%EB%B3%B4%EC%99%84\" aria-label=\"3 hash의 단점 및 보완 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Hash의 단점 및 보완</h2>\n<p>Hash에는 널리 알려진 단점이 존재한다. Hash collision이 발생하기 때문에 hash value가 중복되는 입력값을 찾기만 하면 입력값이 같다고 속일 수 있다. Birthday paradox와 접목되면 일부 알고리즘(대표적으로 MD5)에서는 아주 빠른 속도로 중복되는 hash value를 찾을 수 있게 되는데, 이를 <code class=\"language-text\">birthday attack</code>이라고 한다. Hash function자체가 아주 빠른 속도를 가지고 있기 때문에 공격자들이 아주 빠르게 임의의 문자열의 digest와 공격할 대상의 digest를 비교할 수 있다.</p>\n<p>이를 보완하기 위해 원문에 임이의 문자열을 붙여서 hash function을 거치도록 만들 수 있다. 이를 <code class=\"language-text\">salting</code>이라고 하고 이 때 붙이는 문자열을 <code class=\"language-text\">salt</code>라고 한다. 이 방법을 사용하면 공격자가 Digest를 알아내더라도 salt와 함께 확인을 하게 되므로 공격자가 Salt까지 찾아야 해서 공격 난이도가 상승한다. <a href=\"https://d2.naver.com/helloworld/318732\">Naver D2의 안전한 패스워드 저장</a> 글에서는 모든 패스워드가 고유의 salt를 갖고 salt의 길이가 32바이트 이상이어야 salt와 digest를 추측하기가 어렵다고 얘기하고 있다.</p>\n<p>Key stretching을 통해서 hash function의 속도와 관련된 단점을 보완할 수 있다. Hash function의 수행을 여러번 반복하는 방식이다. 원문을 가지고 Hash function을 통해 Digest를 만들고, 생성된 digest를 가지고 또 다시 hash function을 거쳐 digest를 만들고.. 이를 반복하여 하나의 digest를 생성할 때 어느정도 이상의 시간이 소요되도록 만든다. Rainbow table을 활용한 rainbow attack및 brute force attack으로 패스워드를 추측하기 힘들게 만든다. 마찬가지로 <a href=\"https://d2.naver.com/helloworld/318732\">위에서 언급한 Naver D2의 포스팅</a> 에 따르면 Key stretching을 적용하면 동일한 장비에서 비교할 수 있는 Digest 수를 격감시켜준다고 한다.</p>\n<p>Adaptive key derivation function은 digest 생성 시 salting과 key stretching을 반복하고 salt와 password 외에도 입력값을 더 받아서 공격자가 digest를 유추하기 더 힘들도록 하는 방법이다. PBKDF2, bcrypt, scrypt등의 방식이 있다고 한다. (<a href=\"https://d2.naver.com/helloworld/318732\">참고</a>) <a href=\"https://docs.oracle.com/javase/8/docs/api/javax/crypto/spec/PBEKeySpec.html\">Java의 PBEKeySpec</a>를 사용하면 PBKDF2를 쉽게 적용할 수 있다.</p>\n<h2 id=\"4-symmetric-key-algorithm\" style=\"position:relative;\"><a href=\"#4-symmetric-key-algorithm\" aria-label=\"4 symmetric key algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Symmetric-key algorithm</h2>\n<p>암호화와 복호화에 같은 키를 쓰는 알고리즘을 Symmetric-key algorithm(대칭키 알고리즘) 이라고 부른다. 같은 키를 가지고 암호화/복호화가 진행되기 때문에 송신자로부터 키를 받지 못하면 복호화를 진행할 수 없게 된다.</p>\n<p>키의 크기가 상대적으로 작고, 비대칭키에 비해 암호화와 복호화 속도가 빠르다. 다만 키 교환시의 보안이 고려되어야 하므로 키가 교환되는 과정에서 SSL같은 공개키 암호에 기반하거나 Kerberos같이 중앙 기관을 통해 키 교환을 해야 한다. 또한 키를 교환하는 시스템이 늘 때 마다 고유한 키가 생성되어야 하므로 그 수가 많을 수록 키의 수도 증가하므로 키 관리가 어렵다.</p>\n<p>대표적인 대칭키 알고리즘에는 과거의 DES, 현재의 RC4나 AES등이 있다.</p>\n<h2 id=\"5-public-key-algorithm-asymmetric-algorithm\" style=\"position:relative;\"><a href=\"#5-public-key-algorithm-asymmetric-algorithm\" aria-label=\"5 public key algorithm asymmetric algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. Public-key algorithm (asymmetric algorithm)</h2>\n<p>Public-key algorithm(공개키 알고리즘)은 위에서 언급한 대칭키 암호의 키 전달시의 단점을 보완하고자 만들어졌다. 저장소 등에 공개된 키를 요청자가 획득하고 요청자는 획득한 공개키를 바탕으로 평문을 암호화해서 수신자에게 전달한다. 수신자는 전달받은 암호문을 가지고 있는 개인키로 복호화한다. 서명을 전달할 때는 이 과정을 반대로 수행한다. 개인키로 암호화를 하고 전달하면 공개키로 복호화를 하는 방식이다. (공개키로 개인키를 복호화 할 수 없어야 한다.)</p>\n<p>키가 공개되어 있어서 따로 배포할 필요가 없다. 대체적으로 bit수가 많고 암호화/복호화의 수행시간이 긴 편이다. 그리고 키가 공개되어 있기 때문에 따로 배포할 필요가 없다.</p>\n<p>대표적으로 소인수분해(RSA), 이산대수(Diffie-Hellman), 타원곡선(ECC) 등의 알고리즘이 공개되어 있다.</p>\n<h2 id=\"6-advanced-encryption-standard-aes\" style=\"position:relative;\"><a href=\"#6-advanced-encryption-standard-aes\" aria-label=\"6 advanced encryption standard aes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. Advanced Encryption Standard (AES)</h2>\n<p>과거에 DES가 있었다. Data Encryption Standard라고.. 이름부터 <code class=\"language-text\">데이터 암호화 표준</code> 이고 과거에는 강력했다고 한다. 블록의 단위는 64비트이고 키 길이도 64비트이지만 키는 패리티 비트를 제외하면 56비트이다. 과거의 컴퓨팅 성능에서는 이 길이의 암호문은 강력했겠지만 현재의 성능을 생각하면 이 길이는 짧다. 취약점 또한 널리 알려져있다. 일단 길이를 언급했듯이 길이가 너무 짧아서 Brute force로도 굉장히 빠른 시간 내에 plain text를 알아낼 수 있으며, 블록 암호를 공격하는 대표적인 방법인 <a href=\"https://en.wikipedia.org/wiki/Linear_cryptanalysis\">linear cryptanalysis(선형 공격)</a>와 <a href=\"https://en.wikipedia.org/wiki/Differential_cryptanalysis\">differntial cryptanalysis</a>(<a href=\"http://www.secmem.org/blog/2019/04/08/%EC%B0%A8%EB%B6%84-%EA%B3%B5%EA%B2%A9%EC%9D%98-%EC%9D%B4%ED%95%B4/\">차분 공격</a>)에 약하다.</p>\n<p>이를 보완하기 위해 triple DES같은 응용도 나왔다. DES를 세번 적용하고(암호화를 세번 한다는 뜻은 아니다) 키의 길이가 세 배 늘어나지만 DES가 갖는 취약점을 그대로 가진다.</p>\n<p>여튼 DES가 안전하지 않다고 증명되어서 새로 고안된 표준이 AES이다. 128bit Block cipher이며, 다양한 길이(128, 192, 256 bit)의 Key를 지원한다. 이 글을 쓰다가 왜 <a href=\"https://ieeexplore.ieee.org/document/6122835\">512bit 같은건 없는지</a> 검색해 봤는데, 나랑 비슷한 글을 읽고 비슷한 생각을 한 사람이 있던 모양이어서 <a href=\"https://crypto.stackexchange.com/questions/20253/why-we-cant-implement-aes-512-key-size\">함께 공유한다</a>. 공유한 글에 대한 요약은 하지 않겠다.</p>\n<p>AES 알고리즘은 아래 사진의 순서대로 암호화와 복호화가 이루어진다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 136.1111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAIAAADzvTiPAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAEP0lEQVQ4y12Ua4+bPBOG+f+/px+qbatlyYEFjA0GgnEIRxNwOAaWpK2a5VFivdHqvT4ZeW6ZmblnpOXBv3//6rpu2/ZyuSzL8vn5uSxL3/fi88k8z3Vdz/MsAqRnKOfc931xXpblcrmUZUkpXZbl9+/ff/786bquruufP39CCIdhqKrqLm7bNggCCKGqqp7n7fd7QkiapkVRUErnefZ9H0IIAIAQ6rouwn78+CH1fZ8kCQBgu91+//7dMAyEUFEUhJAoiuZ5nqZJVVXbtquq6roOIeT7/jiOhmFIHx8fZVkihCzLAgC4rhsEQRzHAABd1zHGaZoCAPI8p5RijAEAhmH4vv/29iZ5nhfHMeccIfT6+pokSVmWx+OxfSCyNU2TUsoYOxwOmqYhhPI832w2EgAgjuNpmiilpml2Xdc0TVmW1+v1WWr4gBDiuu5ms9E0jVIqy7JkGEaSJHme+74PACCElGXJOT+fz8fj8Xa7LcuSZRljTNf19Xr98vIiy7Ku69++fZPCMDwej03TZFlmmmZRFG3bcs6naWqahhByu93atl2WpXrgOA6ltO/79/d36XK5cM5d19U0TVEU0zQJIev1Ok3T0+mUZVnTNEEQ2LbtOA7G+O3tbbVaEUJ+/foldV13Op3SNN3v94qiRFGUpmnTNOM4TtMkLIQxzvOcc14UhWEYGOO6rlVVlZ7W+/v3b1mWX504z7M4G4ax3++TJPE8z3Ec27bDMLwXbBzHtm2rqoqiaLPZcM7Lspz/hxCLXOq6bpoGYxwEwTAM95yHYRCy7Xa7Wq10XYcQFkXxVYwQCsOQUgoh3G63wjz3nKMoKoqi67ogCHRdP51OdV1zzj8+Pp5iUfm2badpwhjHcTyO430wEEJJkpzPZ8/zAACcc5HF15cFYuDiOBad+/z8lEzTZIydTqc4ji3LevZ5HMeu60RQ13Vt29IHiqIAAKIoQghJu90uSZI0TXe7nSzLnucxxpqmmaapqioxz03TLMsShqHneYZhWJYVx/Hr6+u9VeM4hmGIEFJVdbfbRVGk63qapkmSUErFSvA873A47Pf79/d3wzDyPN9ut1JRFGEYOo6DEHp5ebEfMMamaRqGYVmW2+0mfi3Pc8aYpmmWZdV1rWmaBCFECMkPFEVZrVaqqlZVdb1enwWLHoicPc9zXTeKovV6LWGMj8dj3/dZliGExBiLnJ/iw+EAIWSMtW1rWdZut+v7Xtf1+8thGHZdZ1mWpmmMMeGk6/V6eiDElNIwDAkhCCGMcRRFiqJIuq4nD2zblmWZUpqmaRAE8zwPw+A4zjzPWZbhB67ryrIsFqBt21JZllVVJUlCCPE8jxDCGIMQjuPY9/35weVyyfMcIeS67mq12mw2ruveHda27fl8HoahaRqEUP/g/7z11WGMMdGFu8PExe12y7IsDEPOubj4ylN5Pp+jKMqyTKy3/wBq+Zc6nj6qIwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"aes-cycle\"\n        title=\"aes-cycle\"\n        src=\"/static/8a49db9ab20a5dc35e89da80d8a3e103/37523/aes-cycle.png\"\n        srcset=\"/static/8a49db9ab20a5dc35e89da80d8a3e103/e9ff0/aes-cycle.png 180w,\n/static/8a49db9ab20a5dc35e89da80d8a3e103/f21e7/aes-cycle.png 360w,\n/static/8a49db9ab20a5dc35e89da80d8a3e103/37523/aes-cycle.png 720w,\n/static/8a49db9ab20a5dc35e89da80d8a3e103/c6d67/aes-cycle.png 734w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li><strong>Add round key</strong>: 한 열씩 데이터와 key를 더하는 과정이다.</li>\n<li><strong>Sub bytes(Substitute byte)</strong>: S-box table을 이용해서 byte 단위 형태로 블록을 교환하는 과정이다. Rijndael S-box라고 미리 정의된 테이블이 존재한다. 예를 들어 <code class=\"language-text\">0x9a</code>의 경우 <code class=\"language-text\">90</code>, <code class=\"language-text\">0a</code>의 교차인 b8로 변환된다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 414px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 93.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACZklEQVQ4yzWTV47kMAxEff8L9rSjArMk290L7PeC9A4gGFZieFWavn/+5oKv976sx7wey5bmZf+Z93k95mWfl+Nn3nzqi9uypmXPr/e6HWXd8gTAr58tFSzABehI9ciQCuxHSRlLxZRrrrSnmgpsqeZS91RyxVxxqsDbnlsfYn2cF4mxNmtD1FhNrKk1sSZq1rpoV23ahlqz1idAWbcDRSsyi1XiSszamFVaZ21IAsQVSfuwflYgErN+itpUKr7nncSAlNjPATGSIBuxIqt/xUpF0SatP4GiljYVp7UhC4mKNRIjsYpUAX0gizYSzRWIpQACMUkjFmSNzMuOLBU8nkd5EopCFBxlawVEESBBEucSw4EtW0IWFi+7AgELO5WOrIAcp9VBiD1TB8FibXjmZT1iqT+EOSr3/HFNrbFXbuO8ny3Rbuahn8yZtVUkZAEUAKpIJRpGb0EKUC5VXCoD1icBIE8p1dd7gwAgZtGhPAphIAyW5nFZMqBrGXRJbMoF37PTRlb1ZhjFY4Mn9xKcGWtB1NZdBS9QIwdNFchpu7DKYZX/J2LFtbVWAJFF1JDVw6Gw/8uUCyx7ttadTes15CERMSNRFrM2SJ2ThQvUuttTwySAsqzhsMAPxGyNQqRfq0lxT6m18Vi1VISgO8V7XOHXmKm4WQBd8GghGga/TGq5gD8BtUcLt+e8pujWg9GzETcfGz/vLLAJIEd3A9inU8rwnvcgwRWcZK7gl8GlLkGu/mIHP4MFCCjKPsM31/25rs95Xa2Pcd33/T3Pu49znNfn+x3n3c/ruj/jvMd59eu67vv6fP8BTWgAm6Nsf+IAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"s-box-table\"\n        title=\"s-box-table\"\n        src=\"/static/839fac321b7ea8ea2363e04648dd1d3c/b910a/s-box.png\"\n        srcset=\"/static/839fac321b7ea8ea2363e04648dd1d3c/e9ff0/s-box.png 180w,\n/static/839fac321b7ea8ea2363e04648dd1d3c/f21e7/s-box.png 360w,\n/static/839fac321b7ea8ea2363e04648dd1d3c/b910a/s-box.png 414w\"\n        sizes=\"(max-width: 414px) 100vw, 414px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<blockquote>\n<p>출처: <a href=\"https://en.wikipedia.org/wiki/Rijndael_S-box\">https://en.wikipedia.org/wiki/Rijndael_S-box</a></p>\n</blockquote>\n<ul>\n<li><strong>Shift row</strong>: 행 단위로 shift 연산을 한다.\n<ul>\n<li>첫 번째 행은 shift되지 않는다.</li>\n<li>두 번째 행부터 네 번째 행까지 각각 1,2,3자리씩 왼쪽으로 Shift한다.</li>\n<li>이 때 byte안의 bit는 그대로 두고 byte를 교환한다 (byte-exchange transformation)</li>\n</ul>\n</li>\n<li><strong>Mix columns</strong>: 열 단위로 각각의 열을 상수 행렬과 곱해서 새로운 값을 가지는 열을 반환한다.</li>\n</ul>\n<blockquote>\n<p>참고: 행렬 계산을 할 때 곱연산은 xtime으로, 덧셈은 XOR로 계산한다.</p>\n</blockquote>\n<p>각 round마다 쓰이는 round key가 있는데, 이를 생성하는 과정을 <strong>key schedule</strong>이라고 한다. Key schedule은 입력된 key를 바탕으로 하고 과정은 아래와 같다.</p>\n<ul>\n<li>입력된 키의 마지막 4바이트를 뽑아 한 칸씩 shift하고 Sub byte 연산을 한다.</li>\n<li>그 후 round constant(Rcon)과 XOR연산을 한다. 1 round 마다 하나씩 앞에서부터 순서대로 사용하며 그 다음 key의 첫째 열과 XOR한 결과가 첫째 round key의 첫째 열이 된다.</li>\n</ul>\n<h2 id=\"7-java에서의-aes\" style=\"position:relative;\"><a href=\"#7-java%EC%97%90%EC%84%9C%EC%9D%98-aes\" aria-label=\"7 java에서의 aes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7. Java에서의 AES</h2>\n<p><code class=\"language-text\">javax.crypto</code> 패키지를 이용하면 위의 과정을 직접 구현하지 않아도 암호화/복호화를 쉽게 할 수 있다. IV와 KEY를 정하고 <code class=\"language-text\">javax.crypto.Cipher</code> 객체를 생성하고 생성한 cipher 객체에 mode, key iv를 세팅한 후 <code class=\"language-text\">cipher.doFinal()</code> 을 호출하면 된다. 복호화도 마찬가지로 iv와 key가 있다면 cipher 객체를 만들고 mode, key, iv를 세팅한 후 <code class=\"language-text\">cipher.doFinal()</code>을 호출하기만 하면 된다. 아래에 예시 코드를 참고하기를 바란다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CryptoUtil</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> iv <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> key <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">private</span> <span class=\"token class-name\">Key</span> keySpec <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SecretKeySpec</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StandardCharsets</span><span class=\"token punctuation\">.</span>UTF_8<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"AES\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">CryptoUtil</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span>\n\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">encrypt</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> originalString<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">NoSuchAlgorithmException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">GeneralSecurityException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">UnsupportedEncodingException</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">Cipher</span> cipher <span class=\"token operator\">=</span> <span class=\"token class-name\">Cipher</span><span class=\"token punctuation\">.</span><span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"AES/CBC/PKCS5Padding\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        cipher<span class=\"token punctuation\">.</span><span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Cipher</span><span class=\"token punctuation\">.</span>ENCRYPT_MODE<span class=\"token punctuation\">,</span> keySpec<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IvParameterSpec</span><span class=\"token punctuation\">(</span>iv<span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> encrypted <span class=\"token operator\">=</span> cipher<span class=\"token punctuation\">.</span><span class=\"token function\">doFinal</span><span class=\"token punctuation\">(</span>originalString<span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StandardCharsets</span><span class=\"token punctuation\">.</span>UTF_8<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Base64</span><span class=\"token punctuation\">.</span><span class=\"token function\">encodeBase64</span><span class=\"token punctuation\">(</span>encrypted<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">decrypt</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> originalString<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">NoSuchAlgorithmException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">GeneralSecurityException</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">UnsupportedEncodingException</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">Cipher</span> cipher <span class=\"token operator\">=</span> <span class=\"token class-name\">Cipher</span><span class=\"token punctuation\">.</span><span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"AES/CBC/PKCS5Padding\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        cipher<span class=\"token punctuation\">.</span><span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Cipher</span><span class=\"token punctuation\">.</span>DECRYPT_MODE<span class=\"token punctuation\">,</span> keySpec<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IvParameterSpec</span><span class=\"token punctuation\">(</span>iv<span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span>cipher<span class=\"token punctuation\">.</span><span class=\"token function\">doFinal</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Base64</span><span class=\"token punctuation\">.</span><span class=\"token function\">decodeBase64</span><span class=\"token punctuation\">(</span>originalString<span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">StandardCharsets</span><span class=\"token punctuation\">.</span>UTF_8<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"8-python에서의-aes\" style=\"position:relative;\"><a href=\"#8-python%EC%97%90%EC%84%9C%EC%9D%98-aes\" aria-label=\"8 python에서의 aes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>8. Python에서의 AES</h2>\n<p>Python에서는 <a href=\"https://pycryptodome.readthedocs.io/en/latest/src/cipher/aes.html\">PyCryptodome</a>에서 AES를 지원한다. document에도 나와있는 샘플을 참고하여 아래와 같이 암호화/복호화를 구현할 수 있다. 다만 Java에서는 padding이 별 다른 과정 없어도 <code class=\"language-text\">javax.crypto.Cipher</code> 객체를 생성할 때 어떤 알고리즘에 맞춰서 padding 되어야 하는지 명시만 해주면 라이브러리에서 잘 해줬는데, python은 한두줄 정도 따로 구현이 되어야 한다는 차이점은 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> Crypto<span class=\"token punctuation\">.</span>Cipher <span class=\"token keyword\">import</span> AES\n<span class=\"token keyword\">import</span> base64\n\nblock_size <span class=\"token operator\">=</span> <span class=\"token number\">32</span>\npad <span class=\"token operator\">=</span> <span class=\"token keyword\">lambda</span> s<span class=\"token punctuation\">:</span> s <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>block_size <span class=\"token operator\">-</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> block_size<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token builtin\">chr</span><span class=\"token punctuation\">(</span>block_size <span class=\"token operator\">-</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> block_size<span class=\"token punctuation\">)</span>\nunpad <span class=\"token operator\">=</span> <span class=\"token keyword\">lambda</span> s<span class=\"token punctuation\">:</span> s<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span><span class=\"token builtin\">ord</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n\nkey <span class=\"token operator\">=</span> <span class=\"token string\">\"some_letters_with_32bit\"</span>\niv <span class=\"token operator\">=</span> <span class=\"token string\">\"some_letters_with_16bit\"</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">encode</span><span class=\"token punctuation\">(</span>plaintext<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    cipher <span class=\"token operator\">=</span> AES<span class=\"token punctuation\">.</span>new<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> AES<span class=\"token punctuation\">.</span>MODE_CBC<span class=\"token punctuation\">,</span> IV<span class=\"token operator\">=</span>iv<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> base64<span class=\"token punctuation\">.</span>b64encode<span class=\"token punctuation\">(</span>cipher<span class=\"token punctuation\">.</span>encrypt<span class=\"token punctuation\">(</span>pad<span class=\"token punctuation\">(</span>plaintext<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">decode</span><span class=\"token punctuation\">(</span>ciphertext<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    cipher <span class=\"token operator\">=</span> AES<span class=\"token punctuation\">.</span>new<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> AES<span class=\"token punctuation\">.</span>MODE_CBC<span class=\"token punctuation\">,</span> IV<span class=\"token operator\">=</span>iv<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> unpad<span class=\"token punctuation\">(</span>cipher<span class=\"token punctuation\">.</span>decrypt<span class=\"token punctuation\">(</span>base64<span class=\"token punctuation\">.</span>b64decode<span class=\"token punctuation\">(</span>ciphertext<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h2 id=\"8-마치며\" style=\"position:relative;\"><a href=\"#8-%EB%A7%88%EC%B9%98%EB%A9%B0\" aria-label=\"8 마치며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>8. 마치며</h2>\n<p>Cryptography와 AES에 대해 겉핥기 식으로 알아보고 Java와 Python에서 이를 빠르게 적용할 수 있는 방법을 알아보았다. 현재의 연산 장비 성능이 너무 좋아진 나머지 AES-128도 안전하지 않다는 얘기를 들어본 것 같지만 그래도 여전히 AES알고리즘은 128, 192, 256 상관없이 권장되는 암호화 알고리즘이다. 다수의 언어들에서도 이를 쉽게 적용할 수 있도록 다양한 라이브러리들이 지원되고 있다. 이 글이 암호화에 대한 인식을 제고하고 나같이 암호화 알고리즘에 대해서 잘 모르는 사람들도 쉽게 암호화를 하는데 도움이 되길 바란다.</p>","frontmatter":{"date":"December 01, 2019","title":"암호화 겉핥기","categories":"Tech","author":"fleta","emoji":"🔮"},"fields":{"slug":"/chat/crypto/about-cryptography-and-its-example/"}},"prev":{"id":"ca53bcfb-7102-5591-afa2-1eb10b7f7154","html":"<h1 id=\"서론\" style=\"position:relative;\"><a href=\"#%EC%84%9C%EB%A1%A0\" aria-label=\"서론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>서론</h1>\n<p>폭발적으로 성장하는 서비스들은 그 성장세를 효과적으로 처리하기 위한 고민을 한다. 감사하게도 내가 있는 회사의 서비스도 굉장히 폭발적으로 성장하였다. 2020년 11월에 입사해서 어느덧 1년이 다 되어가는데, 그 사이에 매출이 거의 2.5배 정도로 뛰었다. 작년 11월에 입사했을 때도 거의 매일같이 순 거래액을 갱신할 정도로 크게 성장했는데, 그 이후에도 멈추지 않고 현재까지 달려왔다. ‘이 목표액 달성하면 전 직원 하와이 보내드리겠습니다’ 하고 CEO가 얘기한 조금은 허황되어 보였던 금액도 지금이라면 진짜 달성할 것 같다고 생각할 정도로 많이 성장했다. 우리 메인 페이지의 트래픽도 많이 늘었듯이 내가 담당하는 백오피스 시스템의 시스템 메트릭들도 껑충껑충 뛰고 있다. 물론 메트릭이 뛰는 이유는 대체로 과거에 이 시스템이 개같이 만들어졌고 그것을 적절한 시기에 청산하지 못한 잘못이 제일 크지만, 이 서비스를 갈아엎고 새 서비스를 만드는게 기존 서비스를 수정하는 것과 비슷한 공수가 들 것이라 생각하면서 자연스럽게 대규모 시스템들은 어떻게 설계가 되는지 관심을 갖게 되었다. 그래서 최근에 몇 가지 도서와 여타의 자료들을 찾아보게 되었고, 그 과정에서의 나의 부족한 생각들을 기록으로 남기고자 글을 적는다.</p>\n<p>기본적이고 추상적인 개념들부터 그 개념들에 대한 나름 상세한 고찰(?)을 반복하는 식으로 글을 적게 될 것 같다. 오늘처럼 며칠 어치 작게 공부한 내용들을 모으면 이렇게 하나의 글을 적을 수 있게 된다. 그런 식으로 설계에 대해서만 한 달 정도에 거쳐 5개 내외의 글을 적게 될 것 같다. 오늘 적을 글은 시스템 설계시 고려되는 점들에 대해 적어볼 생각이다. 사진에 들어있는 그림들 중에서는 다른 아이콘들에 비해 귀여운 그림이 있는데 이 그림들은 전부 <a href=\"http://www.irasutoya.com/\">이라스토야(irasutoya)</a>에서 배포하는 그림들이다.</p>\n<h1 id=\"설계와-확장성\" style=\"position:relative;\"><a href=\"#%EC%84%A4%EA%B3%84%EC%99%80-%ED%99%95%EC%9E%A5%EC%84%B1\" aria-label=\"설계와 확장성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>설계와 확장성</h1>\n<p>사실 확장성에 대해 얘기하려면 <em>어디에서부터</em> 확장되는지 먼저 얘기해야 한다. 그래서 가장 단순한 구조는 어떻냐는 얘기를 한다면, 물론 어떤 서비스를 만드느냐에 따라 설계에 대한 얘기는 모두 다르지만, 어떤 서비스든지 사용자에게 어떤 기능을 ‘보여줘야’ 한다는 공통점이 있다. 그래서 필수적으로 웹(api) 서버와 그것을 보여주는 어떤 존재들(e.g. 웹페이지, 모바일 어플리케이션 등)이 필요하다. 이렇게 필수적인 존재들만 있다고 했을 때의 구조는 아래와 같다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 81.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAAC8ElEQVQ4y3WUS28aZxSG/bMiVYrUX1BVXXTbRbvoqqq6aJRVumnsVK1raqW2k7jCqh03Na0dnFiUYCiOS7gN2CDMzRiGmsDAwMDcuNh5qhmLyHXM4h3NnJnv+c55z5lvSlENqg2ZWDpHvaVwkCnQUjTaPR25a0mjo5k0eyZdY4AxPKer9+249c1VTeln4H++iWvuFq61NZZufUqv00LumbQUFbU/IpE44I9H8xyXykSEA07EUxTNtKFXwVOqOSQiHBLd9RAOBUh4V2i2ZNqqgayoKMaIYkbgxPsdP3x/jxs33uPhspPBOTQ7vXeBw9GAb1wvufNwl4CwyvTaMqJYp6Ma9gLVOCMQ9+LzObg/P8vNm++zseHCHL25HqiaA7aDIT7+2kE0ESTo/gW53bX9svy1/MqkYuz+9RzPs03uzztICBG6+oSSrUunp1P6t0G2WOH0dYOaJFMoVSiWRcRag9NGi/1wjJ4xQB+c2dlPbMp4F60/pFpr4PX/Tb5UJhxLEIrGOczk2N7xcFKt2Y24XObEDK2g7Zc5JF+q4Np0U291kNpd/ny6zVH+GK0/srt+FXZZ/wNe1uMnG2+B67+7bNAYZmn83LLuL8l69w7Q8ue1JCMkD0llspQqVTs29s4q28pWH56j6gamrmMaF1LGGY6h1q5a/4xQOMq9mRmWFpdYfrRM6ihHMp3BF9izlUwfsfXUzWG5wU9xhdvBJg8SbWpt7TrgiGg8gWPOgdPpZMW5QvFEtBuVP75Q9riM3/eCJ8kaH2xJfLhV56OtOmGxNxn44+ysnd3643X8wX2C+yEblskVSWULiJUKnqLCF74mX/okvvI3iVYnACMxgZnpaRZ+XmD111W8uwGC+6/sMdr75xWpowLFQh53ts0nOxKfv5D5zCMRmQQMR+Pc/fYuiwuL7Ox47EYYozd2UzqqaR8Yen+IKGv8lpaZ26vgznVoKFc8HM9SQ+4QFZIIB+m3p8p1Y9NVdXRNQ5IkDP3ij/sPdYl5+n3HqL4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"basic-architecture\"\n        title=\"basic-architecture\"\n        src=\"/static/0df748a1ff871d5c98dd83d8189e97de/37523/basic_architecture.png\"\n        srcset=\"/static/0df748a1ff871d5c98dd83d8189e97de/e9ff0/basic_architecture.png 180w,\n/static/0df748a1ff871d5c98dd83d8189e97de/f21e7/basic_architecture.png 360w,\n/static/0df748a1ff871d5c98dd83d8189e97de/37523/basic_architecture.png 720w,\n/static/0df748a1ff871d5c98dd83d8189e97de/302a4/basic_architecture.png 1080w,\n/static/0df748a1ff871d5c98dd83d8189e97de/07a9c/basic_architecture.png 1440w,\n/static/0df748a1ff871d5c98dd83d8189e97de/668c6/basic_architecture.png 1692w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>그림의 구조는 서버 한 대가 서비스의 모든 기능을 제공하는 형태이다. (DNS같은 서비스는 생략) 사용자가 웹/모바일 어플리케이션 등의 어떤 인터페이스를 통해 서버에 요청을 하면 한 대의 서버가 모든 기능을 제공하는 형태이다. 가장 빠르게 만들 수 있고, 요즘 cpu나 클라우드 서비스의 가격을 생각하면 어지간한 트래픽은 저렴한 서버 한 대로도 수행할 수 있다.</p>\n<p>위와 같은 구조로 초기 서비스를 만들고 운영하다 보니 사용자가 점점 많아지면 언젠가 서버 한 대로는 트래픽을 안정적으로 수행하기 힘들 때가 온다. 이유는 여러가지가 될 수 있다. 단순하게 예상 가능한 이유 두 가지는 대략적으로 아래와 같다.</p>\n<ol>\n<li>순수하게 사용자가 늘어서 트래픽이 증가했고 서버의 자원이 부족해서 늘어난 트래픽을 처리하지 못 함</li>\n<li>서비스 규모가 커지면서 배포가 잦아졌는데 장비 외적인 이슈(인력부족 등)로 서비스의 안정성이 떨어지는 경우</li>\n</ol>\n<p>만약 1번 케이스라면, 트래픽을 처리하기 위해 <strong><em>scale up</em></strong> 또는 <strong><em>scale out</em></strong> 을 고민할 것이다. <strong><em>Scale up</em></strong> 은 장비의 성능을 올려서 문제를 해결하는 방식이다. Scale up에는 장비의 성능이라는 분명한 한계가 존재하긴 하지만 아주 작은 서비스에서 시작했다면 보통 비용상의 문제로 scale up을 할 여지는 분명히 남아있을 것이고 그럼 하드웨어 성능을 개선하는 것으로 당면한 문제를 빠르게 해결할 수 있다. 반대로 <strong><em>Scale out</em></strong> 은 하나의 장비에서 하던 일을 여러 장비들이 처리할 수 있도록 확장하는 방식이다. 쉽게는 비슷한 수준의 서버를 몇 개 더 띄우고 그 서버들에 서비스를 그대로 배포해서 parellel하게 돌아가는 서비스들을 load balancer로 묶는 방식이다. 각각의 방식은 분명한 장단점이 존재한다.\r\nScale up은 단순히 서버의 사양만 올리는 것이라서 인스턴스의 성능을 바꾸는 것을 제외하면 할 일이 없다. 네트워크 설정도 그대로고 서비스 배포도 똑같이 하면 되고 소프트웨어를 변경할 필요조차 없다. 소프트웨어의 측면에서는 기존과 완전히 똑같기 때문에 데이터의 정합성 이슈에서 굉장히 자유롭다. 그런데 언제까지나 서버의 성능을 올리는 것으로 문제를 해결할 수는 없다. Scale up은 성능이 올라갈수록 가성비가 떨어진다. 그리고 명확한 한계가 존재한다. 언젠가는 너무 비싼 장비를 사야 하거나, 그마저도 못하기 때문이다. 보통 클라우드 환경에서 운영하는 사람들은 인스턴스를 빠르게 띄우고 내릴 수 있는 환경의 특성 때문에 단일 서버로 돌아가는 서비스를 운영하는 케이스가 잘 없다.</p>\n<p>첫 회사는 이미 IDC에 입주해 있었고 AWS를 너무나 싫어했던 나머지 실물서버를 지속적으로 관리하는 방식으로 운영해 왔었다. 이런 환경이라면 스케일업을 할 때는 또 다른 이슈가 생기는데, 바로 공간과 전력 그리고 냉각의 문제이다. 사실 IDC에 입주했다는 시점에서 전력과 냉각 문제는 없을 것 같은데(IDC에서 냉각 이슈가 있으면 그냥 같은 공간을 쓰는 장비들이 전부 다운되는 것 아닌지…) <strong>공간</strong>이 제일 문제이다. 만약 서버의 디스크로 HDD를 사용한다고 가정해보자. (물론 아직까지도 HDD가 달린 서버를 관리하러 IDC에 들어가는 회사라면 즉시 탈주해야 한다) 용량이 부족해서 scale up을 하러 IDC를 방문해서 랙을 봤는데 랙에 공간이 없거나 보드에 SATA포트가 부족하면 어떻게 할 것인가? SATA포트가 없다면 정말 어거지로 외장하드라도 붙일 수 있는데 공간이 부족하면 답이 없다. HDD를 공간 대비 용량이 높은 SSD로 교체하거나 서버를 늘려야 한다.  다른 부속들도 마찬가지다. 이런 공간적인 한계에 미치면 무조건 장비를 바꾸게 된다. (왜 이렇게 길게 적었나 생각해보니 전 회사가 정말 쓰레기같은 서버를 쓰고 있어서 항상 욕을 했었고 이게 결국 트래픽을 못 버티니 새 장비를 구매했는데 어떻게든 싸게 사려고 중고를 샀었고 그 중고 서버의 성능이 정말 처참해서 이럴거면 AWS라도 쓰라고 했던 기억이 있다.)</p>\n<p>Scale out은 서버의 갯수를 늘리는 것을 지칭하는 말이다. 특히 클라우드 환경에서는 새로운 인스턴스를 띄우고 내리는 것이 매우 빠르기 떄문에 서버의 성능 확장을 수평적으로 하는 것이 서비스의 운영에 굉장히 유리한 것으로 보인다. 또한 정말 고성능의 서버를 하나 운영하는 것 보다 저성능의 서버를 여러대 운영하는 것이 가성비가 더 높을수도 있다. 자체적으로 서버실을 가지고 있거나 IDC에 입주했다면 공간적인 문제 때문에 이런 선택을 하기 어려울 수 있지만 클라우드는 얘기가 다르다. 그리고 성능적인 한계가 없다. 새로운 서버를 올릴 여건만 충분하다면 성능적인 측면은 걱정할 일이 없다. 이러한 구조는 굉장히 유연하고 빠르다. 한번에 단일 서버로 트래픽이 몰리는 경우 필연적으로 병목현상이 생길 수 밖에 없는데, 서버를 유연하게 띄울 수만 있다면(autoscaling) 이러한 걱정을 할 일이 없다. 그렇지만 강한 힘에는 강한 책임이 따르는데, 서비스를 수평적으로 운영하기 위해서는 신경써야 할 이슈들이 많다. 여러대의 서버에서 작업을 나누기 때문에 데이터의 정합성 이슈가 있다. 만약 서버에 저장되는 데이터가 있다면 그 데이터를 어떤식으로 공유할 것인지에 대한 기술적인 해결이 필요하다. (e.g. session)</p>\n<p>이제 기존 설계의 문제점을 다시 생각해보자. 사진의 설계에서는 서버도 하나고 DB도 하나이다. 서버 하나에 트래픽이 몰리면 서비스가 무조건 지연되고, 그 서버가 죽으면 모든 유저가 서비스를 사용할 수 없는 대형 장애가 발생한다. DB도 마찬가지다. DB의 리소스가 부족하면 서버가 살아있고 멀쩡한 상태여도 병목이 서비스에 영향을 끼치게 되며, 혹여나 DB 서버에 문제가 생겨서 데이터가 날아간다면 미리 백업을 해두지 않는 이상 복구할 방법이 존재하지 않는다. 현재의 설계에서는 서버와 DB 모두가 <a href=\"https://ko.wikipedia.org/wiki/%EB%8B%A8%EC%9D%BC_%EC%9E%A5%EC%95%A0%EC%A0%90\">SPOF(single point of failure)</a>이다. 그래서 SPOF를 만들지 않기 위해서는 하나의 서버가 다운되기까지해도 전체 서비스에 영향을 끼치지 않는 환경을 만들어야 하기 때문에 어차피 서버의 갯수를 늘려야만 한다. 서버는 그냥 서버를 늘려서 서비스를 똑같이 띄우면 되는데 DB는 어떻게 처리할까? 물론 정말 고성능 DB를 써서 모든 데이터에 대한 관리를 하나의 DB에서 처리해도 된다. 하지만 보통 DB의 데이터는 매우 중요하기 때문에 replication하고, 이를 master-slave라 부르며 관리한다. 원본DB에서는 주로 CUD 요청을 날리고 read는 slave에 요청 하도록 분리할 수 있다. 여기까지 하면 SPOF는 없어진다. 서버도 병렬적으로 여러개이기 때문에 한 서버가 죽더라도 서비스 전체에 영향을 끼치지는 않을 것이며, DB도 모든 DB가 동시에 죽는게 아니라면 master가 죽더라도 slave들 중 하나를 master로 선정해서 다시 운영될 것이고 덕분에 DB장애도 전체 서비스에 영향을 끼치지는 않을 것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 131.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAABYlAAAWJQFJUiTwAAAC+klEQVRIx+2VT28bRRjG8xn4AHyVSnwFDpwoByToBYlDubUHQEUoCpEIIn9kCStKoAWVtihYCZQmKrgxSVonjRP/Sxo7sddrr9f7b2Z3s3HDD+0msdeENge4wWH07sy87zPPvM+j2SHDcfk3x9B/FLBjSzqmiGJvHiaE0ZbopzG+/2JAW2J5Ac7R8UByGNuWwBQejvQwhXshWAQYMtmv1iitZNEMp18kPIKjAFXvUG6YKLrdY/5yht0/uHv9Q+68+go7N5Mc2g10x0MzXBKJzxi9Nczrs1Xev1empllY4gJAOzimuLbC/StvMHL5bQqVOtIPqDZ0RkavcSM5yaUvs7w2vs5e08SW3ssB25ZL4DvsZOZ498YUqeUcQbeLLY+Zmh9mJvMpmW2Fjb3WSVFMnBeoLNEtiSl8lrNblCs1tgol1nN5Hm/mWcluIF0f6fkDSl9oG0v61NUW6cwKO3v77FZrPEwvUzloRAKFindi9hmwWOyQobOJbgnc4DlLvz4iVyiTK5Si73At3A/tcwIQFspzFjtZjwFGvjMdhH9ExxLY7mHvoJqq0dA6tE2BdQoWmt0+p7g8AYwWbUlDt0jNLzAzO8ujzCr7DY1cvkT691XW1jd58GCR1FqR9xYN3kw1WdqzkFKiWSKqH+ihKQ9R6ypffD7GxNgY927fQdE6rD7ZYKdyQPFZlWI+zw9PFd5ZMnkr1eJ2SUL3CNsLeobvMxQeTVXj7kcfk7h6lfmf7rO7X2fxYZqnWwWym9scKA0yy9tcT65yZfxHPvh6jk8mJ5n49nsMx+9f2TgdatjHhZ/JT8+we6BEB4WihIKELhDBc1pKi+3JmyS+m2EqOcrEN0lGvhrHtJ3Y8xWylD6m2sJWmhh1Fe1ZBcM9jESJbmEJdOljFct4SpNC+hembk0zPJ1g7reFfg8HnqqwD8KLwA3pn/faWY70aTtuZK/H65u0DbuX12d4Go2/M+5fcs7Ahd/t+bQTV/nCEWcXOyhsx1lLBhn+/9f7J4B/AuIeiJtlJrqeAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"basic-architecture-error\"\n        title=\"basic-architecture-error\"\n        src=\"/static/6045ff6c7f834ef63ae7267979f00e8c/37523/basic_architecture_error.png\"\n        srcset=\"/static/6045ff6c7f834ef63ae7267979f00e8c/e9ff0/basic_architecture_error.png 180w,\n/static/6045ff6c7f834ef63ae7267979f00e8c/f21e7/basic_architecture_error.png 360w,\n/static/6045ff6c7f834ef63ae7267979f00e8c/37523/basic_architecture_error.png 720w,\n/static/6045ff6c7f834ef63ae7267979f00e8c/302a4/basic_architecture_error.png 1080w,\n/static/6045ff6c7f834ef63ae7267979f00e8c/9239a/basic_architecture_error.png 1246w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 140.55555555555554%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAcCAYAAABh2p9gAAAACXBIWXMAABYlAAAWJQFJUiTwAAAEI0lEQVRIx6WV7U9TZxjG+dP2fcuMX8yWLNkSs2zZMjWLMc7NRL+YLHMkvmDEIf3gNkQjLyIWAVtaUMBCaYsFpNjR0rdzek5PT89LW0B/2/M0xYLMYfbh7t3n7ep1Pff13G3TTRutbO1EybTRTYdSxaG5psu5RjTnRd4v2sRHpfaKSm0be/M1ulxoHDYsF6f+ateBd4FJQMHmYX8vQb+PwT9voek6esWVYDm1xNOns5K1GB8IUDEsfH23CA7fw/9HO4amSsCyXWM9lWL+3kWuXrnM8RMnSWcLlO3quyWnNIMTnaP4Zga4PtBLakPBsBxMu87yX8sEJq7y05lTHDp0mEz+AICm7XCu8y53vF6iM140rURJSLZrZDIpJsZHGB8dob+/D1XTKVnuuwGNimDjksqqxFcSpLIF5iOLrCSSLCeShGPPsevbOPXtgxalUVHTqTG3EOPJbIj1TJ5ofIVxfxBFN+TGolE5uG2aFlH0MveHh9HKDhNTUywsxiUz6c/KAX3YZCgOWbU6g0PTnD//Ox7PI1mcvab+r9hh2JBd5Zuvr3D0i3Y+OXKBjbxO2Xb/H2BgcpFj33XQPzC1S+J7AbY+tZyqMbfwnLX1tBy/D9guhiKLe7RrW0SfL8lKt97fgRm2bhbWsKqbTD+bZ9wfYD2T28WyNTTTplhu5NaraWvtIo3usk3f4AMp2d16LdfEfGuIOct2qLsOrrO7C+0wFBtTmTxLK6tMz4aIxZd5kUiSUzSyikYmr5IpFEnnFDTDJJK1uB03eJw0Jcsdhk0PirvzB4Jc67iGx+PhZlcXNzpvEI4syqfoD04xOf2MkTEfQ8Nezj0p8UFvjk8fKMTzFhXLkcBtb0y9xURgks7r1+m+2Y2n20PXb12EIzH5DFeTKV6mMiSS66y8THFhWuekX+V7n8pCtiKvYBegaABj4z7aL/4qWV672sHlS5eYDYV5NO4jFI4SjsWZi8RIJFNcmTf4clTjh6DOqmJhWnskV6qbzIbm6em5TU9PL7137jL8cIR8UZeFMp06FXdThlWtk8yq+CIJomsbGC3mf6vKIq+tb8gfSecKsoWJptE0v2pYqGWbosi6gVoypX1E7DBs9ZEAEnYR0h54H7H0Yg1fYJLY0gsJWnddNqsOm1WXrVpVZjHeqrqyMG8BNr9v5BUJNjMXloxFle97R7mzWuWXmSKeaIn2Zzrd0RId8zqXQjrLBeuN5L1/lYZVla9GyA0txIhEY0TTGp97VT7uL/BRX4HDgwUODTTyh30F+paNtwH3yhf3arp1NjI5YhmDY4+LfDumcmRI4bivyGfDCl+NqhwdUfcH3Cu9AWxjOTXSus3PMxqnA0VOT6ic8uU5G1T5MahxJlBkOm3uD/hvwEal0QwU0yVTUAnHV2VXUk1HVr78T1H+BkVb99N7xCafAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"add-lb-and-replications\"\n        title=\"add-lb-and-replications\"\n        src=\"/static/4d5d787c3ee567ca1f37f7ef93aa9901/37523/add_lb_and_replications.png\"\n        srcset=\"/static/4d5d787c3ee567ca1f37f7ef93aa9901/e9ff0/add_lb_and_replications.png 180w,\n/static/4d5d787c3ee567ca1f37f7ef93aa9901/f21e7/add_lb_and_replications.png 360w,\n/static/4d5d787c3ee567ca1f37f7ef93aa9901/37523/add_lb_and_replications.png 720w,\n/static/4d5d787c3ee567ca1f37f7ef93aa9901/302a4/add_lb_and_replications.png 1080w,\n/static/4d5d787c3ee567ca1f37f7ef93aa9901/077b7/add_lb_and_replications.png 1166w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>그림만 봐도 뭔가가 늘어났다. 몇 년 안되지만 지금까지 일해온 바로는 이렇게 뭔가가 늘어날 수록 더 민감하게 관리해야 한다. (단순하면 민감하지 않아도 된다는 것은 아니다.) 최초의 설계와 비교했을 때 지금 설계를 운영하기 위해서는 일단 서비스(소프트웨어)가 서로에게 영향을 줄 필요가 없도록 잘 구현되어 있어야 한다. 대충 만들어도 된다고 해서 정말 너무 대충 만들어서 웹 서버와 정기적으로 도는 job들이 다 같은 프로세스로 뜨는 것들이 있다. 이런 서비스는 병렬적으로 돌기 어렵다. 두 인스턴스가 같은 시간에 배포된다면 job들이 같은 시간에 동시에 n번 돌 것이기 때문이다. 이런 케이스라면 일단 웹 서버와 job을 먼저 분리해 내야 한다. 그런데 이제 DB에 무슨 작업을 하는 job들이 돌고 있다면 같은 소스 내에 정의된 DAO들에 의존하고 있을 것이다. ORM으로 DB를 물려서 DB의 데이터를 entity class로 가져오고 어떤 연산을 해서 그 entity들의 값을 바꾼 뒤 다시 update 치는 소스코드들은 언제나 본다. 그렇다면 job을 분리해 내기 위해서는 새 프로젝트에 ORM 세팅과 Entity 정의들을 똑같이 새로 만들어야 한다. 이런식으로 서비스가 분리될 때 마다 매번 entity들을 똑같이 적고 있을 수 없으니 이제 데이터에 접근할 용도의 서비스를 분리하기 시작할 것이다. 이런식으로 나가면 할 일이 정말 많아지는데, 이렇게 <a href=\"https://www.redhat.com/ko/topics/microservices\">어플리케이션을 상호 독립적인 최소 구성 요소로 분할하는</a> 설계를 보고 우리는 <strong>마이크로서비스</strong> 라고 부른다.</p>\n<p>물론 자세히 따지면 load balancing이라는게 무엇인지 이해할 필요도 존재한다. 하지만 어지간한 규모에서는 load balancing에 대해서는 자세히 생각할 필요가 없다. 클라우드 환경이라면 AWS ELB, 아니면 보통 nginx 같은 L7 switch들을 사용하는데, 이런 load balancer들은 application layer에서 load balancing을 수행하기 때문에 패킷을 가지고 트래픽을 분산할 수 있다. 가장 대표적인 예시로, 서비스를 운영하다 보면 그냥 무작위로 도메인이나 아이피를 돌면서 포트가 열려있는지 확인하고 열려있으면 때려보는 중국인 친구들을 방어해야 할 일이 종종 있는데 nginx 하나 붙여놓으면 든든하다. 그래서 load balancer에 대해서는 나도 아직 잘은 모르고, 이 글에서는 나올 일 없을 것이다.</p>\n<p>이번 글에서는 보통 학부생들이 수업 들으면서 띄워보는 웹 서버의 구조를 한 번 그려봤고 그것을 단순하게는 어떻게 개선할 수 있을지 살펴보았다. 다음 글에서는 아마 네트워크나 캐시, CDN 등의 얘기를 할 것 같다.</p>","frontmatter":{"date":"October 11, 2021","title":"주니어의 눈에 비치는 설계 1","categories":"Tech","author":"fleta","emoji":"🔮"},"fields":{"slug":"/chat/tech/architecture-components/"}},"site":{"siteMetadata":{"siteUrl":"https://fleta.github.io","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/java/writing-javadoc/","nextSlug":"/chat/crypto/about-cryptography-and-its-example/","prevSlug":"/chat/tech/architecture-components/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}